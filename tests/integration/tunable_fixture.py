"""Define a tunable_fixture decorator for declarable tunable fixtures."""

from contextlib import contextmanager
from functools import partial, wraps

from typing import Callable, Concatenate, Iterator, ParamSpec, TypeVar

P = ParamSpec("P")
Q = ParamSpec("Q")
T = TypeVar("T")


def tunable_fixture(
    generator: Callable[Q, Iterator[T]],
) -> Callable[Q, Callable[[Callable[Concatenate[T, P], None]], Callable[P, None]]]:
    """Decorator to be applied to the definition of the (tunable) fixture."""

    # Convert the decorated generator (tunable fixture definition) to a context
    # manager to convert it into a fixture
    context_manager = contextmanager(generator)

    def _generated_decorator_for_test(
        *tf_args: Q.args, **tf_kwargs: Q.kwargs
    ) -> Callable[[Callable[Concatenate[T, P], None]], Callable[P, None]]:
        """
        Parametrized decorator that will be applied to the test function.

        The args and kwargs are passed to the defined tunable fixture (generator).
        """

        def _decorator(func: Callable[Concatenate[T, P], None]) -> Callable[P, None]:
            """The decorater generated by the parametrized function in the outer scope."""

            # Create throwaway partial function which removes the injected variable
            # for wrapping the inner function (below)
            # Without this pytest will see the injected parameter and complain of
            # a missing value for it
            new_func = partial(func, None)

            @wraps(new_func)
            def _inner(*args: P.args, **kwargs: P.kwargs) -> None:
                """The replacment for the test function decorated by tunable fixture."""

                with context_manager(*tf_args, **tf_kwargs) as yielded_value:
                    func(yielded_value, *args, **kwargs)

            return _inner

        return _decorator

    return _generated_decorator_for_test
